//---------------------------------------------------------------------------

#include <conio.h>
#include <windows.h>
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
#pragma hdrstop

//---------------------------------------------------------------------------

#pragma argsused

#define MAXLEN 100

typedef struct TPoint 
{ 
	int x; int y; 
	TPoint (int a,int b)
	{
		x=a;
		y=b;
	}
} TPoint;

 struct Piece
 {
	 public:
	 int LenX, LenY;
	 int Arr[5][5];
 };
  
 struct Shape
 {
	 Piece Pieces[8];
	 int count;
 };
     
Shape Shapes[12]=
{
			// Пентомино 1: no rotations, без отражения
			//  #
			// ###
			//  #
      { {3,3,{ { 0, 1, 0, 0, 0 }, { 1, 1, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
      , 1},
            // Пентомино 2: два вращения, без отражения
            // #####
     { {
        {5,1,{ { 2, 2, 2, 2, 2 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {1,5,{ { 2, 0, 0, 0, 0 }, { 2, 0, 0, 0, 0 }, { 2, 0, 0, 0, 0 }, { 2, 0, 0, 0, 0 }, { 2, 0, 0, 0, 0 } }}
       }
      , 2},
            // Пентомино 3: два вращения, отражения
            // #
            // ###
            //   #
     { {
        {3,3, { { 3, 0, 0, 0, 0 }, { 3, 3, 3, 0, 0 }, { 0, 0, 3, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 3, 3, 0, 0 }, { 0, 3, 0, 0, 0 }, { 3, 3, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 3, 3, 0, 0, 0 }, { 0, 3, 0, 0, 0 }, { 0, 3, 3, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 0, 3, 0, 0 }, { 3, 3, 3, 0, 0 }, { 3, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
      }
      , 4},
            // Пентомино 4: четыре вращения, без отражения
            // ###
            // #
            // #
     { {
        {3,3,  { { 4, 4, 4, 0, 0 }, { 4, 0, 0, 0, 0 }, { 4, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3,  { { 4, 4, 4, 0, 0 }, { 0, 0, 4, 0, 0 }, { 0, 0, 4, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3,  { { 0, 0, 4, 0, 0 }, { 0, 0, 4, 0, 0 }, { 4, 4, 4, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3,  { { 4, 0, 0, 0, 0 }, { 4, 0, 0, 0, 0 }, { 4, 4, 4, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 4},
            // Пентомино 5: четыре вращения, без отражения
            //  ##
            // ##
            // #
     { {
        {3,3, { { 0, 5, 5, 0, 0 }, { 5, 5, 0, 0, 0 }, { 5, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 5, 5, 0, 0, 0 }, { 0, 5, 5, 0, 0 }, { 0, 0, 5, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 0, 5, 0, 0 }, { 0, 5, 5, 0, 0 }, { 5, 5, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 5, 0, 0, 0, 0 }, { 5, 5, 0, 0, 0 }, { 0, 5, 5, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 4},
            // Пентомино 6: четыре вращения, без отражения
            // ###
            //  #
            //  #
     { {
        {3,3, { { 6, 6, 6, 0, 0 }, { 0, 6, 0, 0, 0 }, { 0, 6, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 0, 6, 0, 0 }, { 6, 6, 6, 0, 0 }, { 0, 0, 6, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 6, 0, 0, 0 }, { 0, 6, 0, 0, 0 }, { 6, 6, 6, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 6, 0, 0, 0, 0 }, { 6, 6, 6, 0, 0 }, { 6, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 4},
            // Пентомино 7: четыре вращения, без отражения
            // ###
            // # #
     { {
        {3,2, { { 7, 7, 7, 0, 0 }, { 7, 0, 7, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,3, { { 7, 7, 0, 0, 0 }, { 0, 7, 0, 0, 0 }, { 7, 7, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,2, { { 7, 0, 7, 0, 0 }, { 7, 7, 7, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,3, { { 7, 7, 0, 0, 0 }, { 7, 0, 0, 0, 0 }, { 7, 7, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 4},
            // Пентомино 8: четыре вращения, отражения
            // #
            // ###
            //  #
     { {
        {3,3, { { 8, 0, 0, 0, 0 }, { 8, 8, 8, 0, 0 }, { 0, 8, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 8, 8, 0, 0 }, { 8, 8, 0, 0, 0 }, { 0, 8, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 8, 0, 0, 0 }, { 8, 8, 8, 0, 0 }, { 0, 0, 8, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 8, 0, 0, 0 }, { 0, 8, 8, 0, 0 }, { 8, 8, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 8, 8, 0, 0, 0 }, { 0, 8, 8, 0, 0 }, { 0, 8, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 8, 0, 0, 0 }, { 8, 8, 8, 0, 0 }, { 8, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 8, 0, 0, 0 }, { 8, 8, 0, 0, 0 }, { 0, 8, 8, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,3, { { 0, 0, 8, 0, 0 }, { 8, 8, 8, 0, 0 }, { 0, 8, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 8},
            // Пентомино 9: четыре вращения, отражения
            // ####
            //    #
     { {
        {4,2, { { 9, 9, 9, 9, 0 }, { 0, 0, 0, 9, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 0, 9, 0, 0, 0 }, { 0, 9, 0, 0, 0 }, { 0, 9, 0, 0, 0 }, { 9, 9, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 9, 0, 0, 0, 0 }, { 9, 9, 9, 9, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 9, 9, 0, 0, 0 }, { 9, 0, 0, 0, 0 }, { 9, 0, 0, 0, 0 }, { 9, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 9, 0, 0, 0, 0 }, { 9, 0, 0, 0, 0 }, { 9, 0, 0, 0, 0 }, { 9, 9, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 0, 0, 0, 9, 0 }, { 9, 9, 9, 9, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 9, 9, 0, 0, 0 }, { 0, 9, 0, 0, 0 }, { 0, 9, 0, 0, 0 }, { 0, 9, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 9, 9, 9, 9, 0 }, { 9, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 8},
            // Пентомино 10: четыре вращения, отражения
            // ####
            //   #
     { {
        {4,2, { { 10, 10, 10, 10, 0 }, { 0, 0, 10, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 0, 10, 0, 0, 0 }, { 0, 10, 0, 0, 0 }, { 10, 10, 0, 0, 0 }, { 0, 10, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 0, 10, 0, 0, 0 }, { 10, 10, 10, 10, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 10, 0, 0, 0, 0 }, { 10, 10, 0, 0, 0 }, { 10, 0, 0, 0, 0 }, { 10, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 10, 0, 0, 0, 0 }, { 10, 0, 0, 0, 0 }, { 10, 10, 0, 0, 0 }, { 10, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 0, 0, 10, 0, 0 }, { 10, 10, 10, 10, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 0, 10, 0, 0, 0 }, { 10, 10, 0, 0, 0 }, { 0, 10, 0, 0, 0 }, { 0, 10, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 10, 10, 10, 10, 0 }, { 0, 10, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 8},
            // Пентомино 11: четыре вращения, отражения
            // ###
            //   ##
     { {
        {4,2, { { 11, 11, 11, 0, 0 }, { 0, 0, 11, 11, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 0, 11, 0, 0, 0 }, { 0, 11, 0, 0, 0 }, { 11, 11, 0, 0, 0 }, { 11, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 11, 11, 0, 0, 0 }, { 0, 11, 11, 11, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 0, 11, 0, 0, 0 }, { 11, 11, 0, 0, 0 }, { 11, 0, 0, 0, 0 }, { 11, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 11, 0, 0, 0, 0 }, { 11, 0, 0, 0, 0 }, { 11, 11, 0, 0, 0 }, { 0, 11, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 0, 0, 11, 11, 0 }, { 11, 11, 11, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,4, { { 11, 0, 0, 0, 0 }, { 11, 11, 0, 0, 0 }, { 0, 11, 0, 0, 0 }, { 0, 11, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {4,2, { { 0, 11, 11, 11, 0 }, { 11, 11, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 8},
            // Пентомино 12: четыре вращения, отражения
            // ###
            //  ##
     { {
        {3,2, { { 12, 12, 12, 0, 0 }, { 0, 12, 12, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,3, { { 0, 12, 0, 0, 0 }, { 12, 12, 0, 0, 0 }, { 12, 12, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,2, { { 12, 12, 0, 0, 0 }, { 12, 12, 12, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,3, { { 12, 12, 0, 0, 0 }, { 12, 12, 0, 0, 0 }, { 12, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,3, { { 12, 0, 0, 0, 0 }, { 12, 12, 0, 0, 0 }, { 12, 12, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,2, { { 0, 12, 12, 0, 0 }, { 12, 12, 12, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {2,3, { { 12, 12, 0, 0, 0 }, { 12, 12, 0, 0, 0 }, { 0, 12, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }},
        {3,2, { { 12, 12, 12, 0, 0 }, { 12, 12, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } }}
       }
      , 8}

};

static int M, N, P, Solution = 0;
static int Pole[62][62];
COORD position;
HANDLE hConsole;
CONSOLE_SCREEN_BUFFER_INFO bi;
std::ofstream FILE_SAVE_s;

//определяет клетку заданного типа на поле после заданной
static TPoint SearchEmpty1(int Arr[62][62], TPoint st, TPoint end, int d)
{
    for (; st.y < end.y; st.y++)
    {
        for (; st.x < end.x; st.x++)
        {
            if (Arr[st.y][st.x] == d)
            {
                return st;
            }
        }
        st.x = 0;
    }
    return st;
}

//определяет клетку заданного типа в шаблоне фигуры после заданной
static TPoint SearchEmpty( int Arr[5][5],   TPoint st, TPoint end, int d)
{
    for (; st.y < end.y; st.y++)
    {
        for (; st.x < end.x; st.x++)
        {
            if (Arr[st.y][st.x] == d)
            {
                return st;
            }
        }
        st.x = 0;
    }
    return st;
}

//определяет наличие хотя бы пяти свободных клеток относительно заданной
static int    CountEmpty(  int y, int x,int Count)
{
    if ((y < 0) || (x < 0)) return Count-1;      //если вышли за диапазон, то выходим
    if (Pole[y][ x ] == 0)                       //если клетка пустая
    {
        if (Count == 4) return 5;                  //уже нашли 4-е, значит это пятая и выходим
        
		Pole[y][x ] = 20;                          //указываем, что эту клетку сосчитали

        Count = CountEmpty(y, x + 1, Count + 1);   //переходим на соседнюю
        if (Count < 5)                             //если не нашли пять, то ищем дальше
        {
            Count = CountEmpty(y + 1, x, Count + 1);      //переходим на соседнюю
            if (Count < 5)                                //если не нашли пять, то ищем дальше
            {
                Count = CountEmpty(y, x - 1, Count + 1);     //переходим на соседнюю
                if (Count < 5)                               //если не нашли пять, то ищем дальше
                {
                    Count = CountEmpty(y - 1, x, Count + 1);   //переходим на соседнюю
                }
            }
        }
        Pole[y][ x] = 0; //на выходе удаляем признак подсчета клетки
    }
    else return Count - 1;
    return Count; //выходим с найденным количеством
}

//основная функция поиска решения
static void   FindSolutions( int i )
{
    TPoint pt ( 0, 0 );
    int j = 0; // номер формы
    while ( true )
    {
        //поиск пустой клетки на поле куда можно поставить текущую фигуру
        pt = SearchEmpty1(Pole, pt,  TPoint(N, M), 0);
        if (pt.y == M)
        {
            break;
        }

		// пока не попробовали все повороты и отражения
        while (Shapes[i].count != j)
        {
            //поиск первой непустой клетки в фигуре по горизонтали
            TPoint f = SearchEmpty(Shapes[i].Pieces[j].Arr,  TPoint(0, 0),  TPoint(5, 5), i + 1);
            
			//пробуем вставлять, если выполняются условия, перебирая формы фигуры
            if (pt.x - f.x >= 0 && (pt.x - f.x) + Shapes[i].Pieces[j].LenX <= N && pt.y + Shapes[i].Pieces[j].LenY <= M)
            {
                //вставка, если входит в границы
                bool s = true;
                int d = f.x;

                //проверим можно ли вставить
                for (int y = 0; y < Shapes[i].Pieces[j].LenY; y++)
                {
                    for (int x = 0; x < Shapes[i].Pieces[j].LenX; x++)
                    {
                        if (Shapes[i].Pieces[j].Arr[y][ x] == i + 1)
                            if (Pole[pt.y + y][ pt.x -f.x + x] != 0)
                            {
                                s = false;
                                x = Shapes[i].Pieces[j].LenX; //выходим из циклов
                                y = Shapes[i].Pieces[j].LenY;
                            }
                    }
                }

                //вставляем
                if (s)
                {
                    for (int y = 0; y < Shapes[i].Pieces[j].LenY; y++)
                    {
                        for (int x = 0; x < Shapes[i].Pieces[j].LenX; x++)
                        {
                            Pole[pt.y + y][ pt.x - f.x + x] += Shapes[i].Pieces[j].Arr[y][ x];
                        }
                    }

					//находим начальную точку для проверки на зажатость
        			int y1 = pt.y - 1;   
                    int x1 = pt.x - f.x - 1;

					//коррекция, чтобы не вылезть за диапазон
                    if (y1 < 0) y1 = 0;  
                    if (x1 < 0) x1 = 0;

                    //проверка зажатой клетки
                    for (int y = y1; y < y1+Shapes[i].Pieces[j].LenY + 2; y++)
                    {
                        for (int x = x1; x < x1+Shapes[i].Pieces[j].LenX + 2; x++)
                        {
                            if (Pole[y][ x] == 0)
                            {
                                if (CountEmpty(y,x,0)<5) //если соседних клеток меньше 5-и, то
                                {
                                    s = false;
                                    x = N; //выходим из цикла, так как нашли место, которое нельзя уже ни чем заставить
                                    y = M;
                                }
                            }
                        }
                    }

                    if (s)
                    {                        
                        //если не все фигуры просмотрены, то продолжить искать
                        if (i < 11)
                        {
                            FindSolutions(i + 1);
                            //удаление фигуры
                            for (int y = 0; y < Shapes[i].Pieces[j].LenY; y++)
                            {
                                for (int x = 0; x < Shapes[i].Pieces[j].LenX; x++)
                                {
                                    Pole[pt.y + y][ pt.x - f.x + x] -= Shapes[i].Pieces[j].Arr[y][ x];
                                }
                            }
                            j++;
                            //вывод поля
        						
                        }

                        else
                        {
                            //проверка матрицы на заполнение
                            TPoint pr = pt;
                            pt = SearchEmpty1(Pole,  TPoint(0, 0),  TPoint(N, M), 0);

                            if (pt.x == 0 && pt.y == M)
                            {
                                Solution++;
								GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &bi);
								position=bi.dwCursorPosition;
                                std::cout<<"Решений : " <<Solution<<"\r\n";
                                FILE_SAVE_s<<" Решений : " <<Solution<<"\r\n";
                                        
                                //вывод поля и запись в файл
                                for (int y = 0; y < M; y++)
                                {
                                    for (int x = 0; x < N; x++)
                                    {
                                        char c = (char)(Pole[y][ x] + 0x30);
                                        if (Pole[y][ x] < 0) c = ' ';
                                        if (Pole[y][ x] > 9)
                                            c = (char)(Pole[y][ x] - 10 + 'a');
                                        std::cout<<" "<< c;
                                        FILE_SAVE_s<<" "<< c;
                                    }
                                    std::cout<<"\r\n";
                                    FILE_SAVE_s<<"\r\n";
                                }
								SetConsoleCursorPosition(hConsole, position);
                            }
                            pt = pr;

							//удаление фигуры
                            for (int y = 0; y < Shapes[i].Pieces[j].LenY; y++)
                            {
                                for (int x = 0; x < Shapes[i].Pieces[j].LenX; x++)
                                {
                                    Pole[pt.y + y][ pt.x - f.x + x] -= Shapes[i].Pieces[j].Arr[y][ x];
                                }
                            }
                            j++;

                        }
                    }
                    else
                    {
                        //удаление фигуры
                        for (int y = 0; y < Shapes[i].Pieces[j].LenY; y++)
                        {
                            for (int x = 0; x < Shapes[i].Pieces[j].LenX; x++)
                            {
                                Pole[pt.y + y][ pt.x - f.x + x] -= Shapes[i].Pieces[j].Arr[y][ x];
                            }
                        }
                        j++;
                    }
                }//если не вставили
                else { j++; }
            }//если выходит за границы
            else { j++; }
        }//end while
        
		j = 0;

        // иначе сдвигаем на 1 
        pt.x++;
        if (pt.x == N )
        {
            pt.x = 0; pt.y++;
            if (pt.y >= M )
            {
                break;
            }
        }
    }
}

int main(int argc, char* argv[])
{
	FILE *f;
	char s[MAXLEN];
    
	setlocale(LC_ALL, "Russian");
	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    
	std::cout<<"Решатель пентамино для произвольной фигуры!\n";

    string name_file;            //имя файла с исходными данными

    if (argc == 2)               //если есть параметр командной строки то
        name_file = argv[1];     //считаем имя из командной строки
    else
        name_file = "input.txt"; //иначе по умолчанию
	
	FILE_SAVE_s.open("output.txt",std::ios_base::trunc);
    
	if((f = fopen(name_file.c_str(),"r")) != NULL)
    {
        std::cout<<"Фигура : "<<"\r\n";

		//чтение конфигурации поля
        for (int y = 0; y < 62; y++)
            for (int x = 0; x < 62; x++)

                Pole[y][x] = -1;  //начальное заполнение поля
                int k = 0, l = 0, col = 0;
                M = 0; N = 0;     //начальный размер рабочего поля
                
                while ( !feof(f) )
                {
                    fgets(s, MAXLEN, f);
					k=0;
					while ((s[k]!=0)&&(s[k]!='\n'))
					{
                        if (s[k] == ' ')
                            Pole[l][ k] = -1;
                        else
                        {
                            Pole[l][ k] = 0;
                            col++;
                            if (k > N) N = k;  //корректируем ширину поля исходя из размеров считанного рисунка
                        }
						k++;
					}
                    l++;
                }
                fclose(f);

                N++;
                M = l; //высота поля
                
				//вывод поля
                for (int y = 0; y < M; y++)
                {
                    for (int x = 0; x < N; x++)
                    {
                        char c = (char)(Pole[y][ x] + 0x30);
                        if (Pole[y][ x] < 0) c =' ';
                        else
                            if (Pole[y][ x] > 9)
                            c = (char)(Pole[y][ x] - 10 + 'a');
                        std::cout<<" " << c;
                    }
                    std::cout<<"\r\n";
                }

        if (col == 60)
        {
            //  Pole = new int[M, N];
            std::cout<<"Поиск решений . . .\n";
            FindSolutions( 0 );
			for (int i_n = 0; i_n < M + 1; i_n++) std::cout << "\n";
            std::cout<<"\nЗапись в файл . . .\n";
        }
        else
        {
            std::cout<<"Площадь прямоугольника != 60\n";
        }

    }
	FILE_SAVE_s.close();
		
	system("Pause");
    return 0;
}
