Согласно Википедии:

> Пентамино́ (от др.-греч. πέντα пять, и домино) — пятиклеточные полимино, то есть плоские фигуры, каждая из которых состоит из пяти одинаковых квадратов, соединённых между собой сторонами («ходом ладьи»). Этим же словом иногда называют головоломку, в которой такие фигуры требуется укладывать в прямоугольник или другие формы.
>
> [статья на Википедии](https://ru.wikipedia.org/wiki/Пентамино "")  


## Описание игры
Программа находит все заполнения произвольной фигуры полным набором пентамино. Пентамино -- это плоская фигура, состоящая из пяти одинаковых квадратов, соединённых между собой сторонами. Всего существует 12-ть разных таких фигур. Таким образом, общий объем произвольной фигуры должен быть 60 квадратов.

![Фигуры в пентамино](http://gameplay3d.clan.su/_bl/0/s72656194.jpg)

## Описание программы
### Переменные
В программе определены: 

* struct TPoint  -- тип "клетка на поле" с координатами на нём;
* struct Piece -- тип "фигура" определяемый с помощью ширины LenX, высоты LenY и массива 5х5 описывающего форму фигуры; 
* struct Shape -- тип "все вариации фигуры" с массивом фигур на 8 элементов (с учётом зеркального расположения таких вариантов может быть максимум 8-мь) и числом фигур count;
* Shape Shapes[12] -- массив (Shapes) со всеми 12-ю фигурами и для каждой фигуры определены все возможные (разные) варианты её расположения на плоскости; 
* static int Pole[62][62] -- массив поля 60х60 с границами.

### Функции
#### Функция main()
При старте программы в основной функции (main) проверяется наличие параметра командной строки, которым задаётся имя исходного файла, при отсутствии параметра имя берётся по умолчанию «input.txt». Файл открывается на чтение, и если открытие удачное (файл существует), то считываются строки исходного файла и заполняется массив поля (Pole) -- при наличии в файле символа отличного от пробела, элемент массива заполняется в нулём -- это признак клетки, которую надо будет при обработке замостить пентамино. Первоначально весь массив заполняется числом -1 -- это признак того, что поле не используется в расчёте. При заполнении массива нулями происходит подсчёт таких ячеек и если после считывания всего исходного файла таких ячеек окажется не 60, то выводится сообщение об ошибке и работа программы завершается.
 
#### Функция SearchEmpty1()
Определяет клетку заданного типа на поле после заданной
		
		static TPoint SearchEmpty1(int Arr[62][62], TPoint st, TPoint end, int d)
		{
		    for (; st.y < end.y; st.y++)
		    {
		        for (; st.x < end.x; st.x++)
		        {
		           if (Arr[st.y][st.x] == d)
		            {
		                return st;
		            }
		        }
		        st.x = 0;
		    }
		    return st;
		}

#### Функция SearchEmpty
Определяет клетку заданного типа на поле после заданной
		
		static TPoint SearchEmpty( int Arr[5][5],   TPoint st, TPoint end, int d)
		{
		    for (; st.y < end.y; st.y++)
		    {
		        for (; st.x < end.x; st.x++)
		        {
		            if (Arr[st.y][st.x] == d)
		            {
		                return st;
		            }
		        }
		        st.x = 0;
		    }
		    return st;
		}

#### Функция CountEmpty
Определяет наличие хотя бы пяти свободных клеток после заданной
		
		static int CountEmpty(  int y, int x,int Count)
		{
		    //если вышли за диапазон, то выходим
		    if ((y < 0) || (x < 0)) return Count-1; 

			//если клетка пустая
		    if (Pole[y][ x ] == 0)                  
		    {
				//уже нашли 4-е, значит это пятая и выходим
		        if (Count == 4) return 5;           
		
			//указываем, что эту клетку сосчитали
		    Pole[y][x ] = 20;                       
		
				//переходим на соседнюю
		        Count = CountEmpty(y, x + 1, Count + 1);   
				//если не нашли пять, то ищем дальше
		        if (Count < 5)                             
		        {
					//переходим на соседнюю
		            Count = CountEmpty(y + 1, x, Count + 1);      
					//если не нашли пять, то ищем дальше
		            if (Count < 5)                                
		            {
						//переходим на соседнюю
		                Count = CountEmpty(y, x - 1, Count + 1);     
						//если не нашли пять, то ищем дальше
		                if (Count < 5)                               
		                {
							//переходим на соседнюю
		                    Count = CountEmpty(y - 1, x, Count + 1);   
		                }
		            }
		        }
				//на выходе удаляем признак подсчета клетки
		        Pole[y][ x] = 0; 
		    }
		    else return Count - 1;
			//выходим с найденным количеством
		    return Count; 
		}


### Алгоритм
Поиск решения происходит в рекурсивной функции (FindSolutions) в параметрах функции передаётся номер пентамино из массива Shapes. В функции FindSolutions в цикле определяется с помощью функции SearchEmpty1 номер ячейки, которая ещё не занята пентамино и дальше в цикле происходит попытка расположить заданную пентамино в заданную позицию с учётом всех возможных вариантов поворота пентамино, если не удалось этого сделать, то происходит переход на следующую свободную клетку. Если удалось расположить пентамино, то происходит анализ на клетки, которые уже никак не удастся заполнить (менее четырёх клеток, которые изолированы в исходной фигуре при текущем расположении пентамино), такой анализ осуществляется с помощью функции CountEmpty для всех клеток в окружении располагаемого сейчас пентамино. Если «зажатых» клеток не обнаружено, то текущее расположение пентамино запоминается и происходит переход к расположению следующей фигурки пентамино (происходит вызов функции FindSolutions со следующим номером пентамино). При обнаружении «зажатых» клеток новое расположение пентамино удаляется с поля и происходит переход на анализ расположения пентамино в следующую пустую клетку поля. Если все клетки были заполнены, то происходит запись результата в выходной файл «output.txt» и анализ продолжается. Когда все варианты были рассмотрены, то происходит выход из функции FindSolutions и в главной функции (main) закрывается файл «output.txt». Далее ожидается выход из программы по нажатию клавиши.

### Вывод результатов
При старте программы перезаписывается файл результата работы программы «output.txt». При удачном завершении работы программы, в файле "output.txt" построчно записываются решения (массивы Pole в виде строки).
